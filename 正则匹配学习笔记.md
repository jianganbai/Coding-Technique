# 正则匹配学习笔记

## 元字符

- 正则表达式定义了一种匹配范式
- 正则表达式中大多数字母和字符只允许与自己匹配
  - 匹配表达式`'a'`只会匹配字符'a'
- 元字符则扩展匹配方式

### 匹配字符

#### `[]`

- 字符类`[]`用于匹配括号内的字符，默认只匹配1个字符
  - 括号内元素全部当做纯粹的字符看待，取消转义、元字符等功能
    - 对于`\n`, `\t`这些字符而言，依旧把`\`与后一个字符结合而看
  - 括号内字符不需要使用逗号隔开
  - `[abc]`代表匹配字符a，b和c
  - `[a-z]`代表匹配字符a-z
  - `[^a]`代表匹配除a以外的所有字符
    - `'^'`作为元字符还有“只在行开头匹配”的功能

#### `\`

- `\`表示某些预定义的字符集
- 常用：
  - `\w`匹配任何字母数字字符，相当于`[a-zA-Z0-9]`
  - `\d`匹配任何十进制数字，相当于`[0-9]`
  - `\D`匹配任何非数字字符，相当于`[^0-9]`
  - `\s`匹配任何空白字符，相当于`[\t\n\r\f\v]`
  - `\S`匹配任何非空白字符，相当于`[^\t\n\r\f\v]`
  - `\w`匹配任何字母与数字字符，相当于`[a-zA-Z0-9_]`
  - `\W`匹配任何非字母与非数字字符，相当于`[^a-zA-Z0-9_]`
- `\_`可包含在`[]`中
  - `[\s,.]`匹配任何空白字符或`','`或`'.'`
- 使用`'\\'`表示后面的`'\'`当做字符处理
  - 如使用`'\section'`，则会把前2位当成1个正则字符`'\s'`
  - 为匹配字符串'\section'，正则表达式应修改为`\\section`
  - `\`也称为转义字符

#### `.`

- `.`匹配除换行符之外的任何字符

#### `|`

- `A|B`代表匹配A或匹配B，优先级很低
  - 匹配字面的`'|'`时，使用`'\|'`

#### `^`

- `^`代表在行的开头匹配
  - 默认多行文本是一个大的字符串，所以匹配时当做字符串匹配
  - 加入`^`后则仅在每个'\n'后进行匹配

#### `$`

- `$`代表仅匹配各行的末尾位置

### 重复字符

#### `*`

- `*`前一个字符匹配0次-多次
  - 正则表达式`'ca*t'`可匹配`'ct'`, `'cat'`, `'caaat'`等
  - 正则表达式`'c[abc]*t'`可匹配`'cat'`, `cbt`, `cabcat`
  - 前一字符使用`[]`表示时，只要字符串中某位包含`[]`里面的元素，就认为匹配上了
  - 有`'*'`的正则表达式匹配时，保存前一字符出现次数最多的结果

#### `+`

- 前一字符匹配1次-多次

#### `?`

- 前一字符匹配0次-1次

`{m, n}`

- 前一字符至少重复m次，至多重复n次
  - m缺省代表0次，n缺省代表无穷多次

## 正则表达式

### 概览

- python提供了`re`库来进行正则匹配
- python中的正则表达式使用字符串表示
  - 例：`'abc*d'`表示可匹配`'abd'`的正则表达式
  - 正则表达式中的`'\'`会与Unicode部分字符的表示冲突
    - 如：使用正则表达式`'\n'`只能匹配换行符，不能匹配连续的`'\'`和`'n'`
    - 法1：使用`'\\'`代替所有`'\'`，表示后一个`'\'`不与后面的字符组合成其它字符
      - `'\\section'`应替换为`'\\\\section'`
    - 法2：在字符串前加`'r'`，如`r'\\section'`
      - 加`'r'`是在正则表达式字符串前面加的
- 使用方法：
  - 正则表达式先被编译成模式对象
  - 模式对象调用多种匹配函数进行匹配，返回匹配对象/匹配结果
  - 匹配对象带有多种函数，可获得匹配情况

### 使用

#### 编译

- `p = re.compile('[a-z]+')`
  - `'[a-z]+'`为正则表达式
  - `re.compile()`将正则表达式表以为模式对象p，然后使用p的内置函数进行匹配

##### 编译标志

- `p = re.compile('[a-z]+', re.IGNORECASE)`
- `re.ASCII`：使转义字符按照ASCII的含义匹配，取消正则匹配中的转义含义
  - `\w`, `\b`等当做ASCII字符处理，而不再当做匹配字符处理
- `re.DOTALL`：使`'.'`匹配任何字符，包括换行符（原来不匹配）
- `re.IGNORECASE`：匹配时忽略大小写
- `re.MULTILINE`：进行多行匹配
- `re.VERBOSE`：忽略正则表达式中的空格，使表达式变得易读

#### 匹配

- 对于编译好的模式对象`p`
  - `p.match(string)`确定是否从string的开头进行匹配
    - 成功则返回匹配对象，失败则返回None
  - `p.search(string)`查找各种匹配可能
    - 成功则返回匹配对象，失败则返回None
    - 每次只能返回1个匹配结果
  - `p.findall()`找到正则匹配的所有子字符串，并将它们作为列表返回
  - `p.finditer()`找到正则匹配的所有子字符串，并将它们返回为一个iterator
    - 迭代器每次返回的结果与search返回的结果格式一致
      - 每次匹配均选择匹配结果最长的结果
    - 通过不断迭代可获得所有匹配结果
- 也可使用模块级函数
  - `re.match(<正则表达式>, string, <编译标志>)`
  - `re.search(<正则表达式>, string, <编译标志>)`

#### 匹配对象

- 对于匹配对象`m`
- `m.group()`返回正则匹配的字符串
  - 仅1个匹配结果
- `m.start()`返回匹配的开始位置
- `m.end()`返回匹配的结束位置
- `m.span()`返回包含匹配(start, end)位置的元组

### 分组

- 使用`'(<正则表达式>)'`表示正则表达式中的一部分构成一组
  - 从左到右按照左括号的顺序对各组从1开始编号，0为整个正则表达式
  - 每个左括号和对应的右括号构成一组
  - 可能出现括号嵌套括号：`(a(b)c)d`
    - 组0为`abcd`，组1为`abc`，组2为`b`
- 匹配时先保证整个正则表达式能匹配上，然后分别记录各个组的匹配结果
- 设匹配对象为`m`
  - `m.group()`返回整个正则表达式的匹配字符串
  - `m.group(1)`返回编号为1的组的匹配字符串
  - `m.group(2,3)`返回一个元组：（组2的匹配结果，组3的匹配结果）
  - `m.groups()`返回各子组的匹配字符串：（组1的匹配结果，组2的匹配结果，。。。）

## 修改字符串

### split()

- `p.split(string, maxsplit=0)`

  - 找出string中各匹配的位置，记录相邻匹配位置间的字符串，返回这些字符串组成的元组

  - `maxsplit`为最大拆分次数，亦即最大匹配次数

  - ```python
    >>> p = re.compile(r'\W+')  # \W代表匹配所有非字母与非数字字符
    >>> p.split('This is a test, short and sweet, of split().')
    ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']
    >>> p.split('This is a test, short and sweet, of split().', 3)
    ['This', 'is', 'a', 'test, short and sweet, of split().']
    ```

  - 若要获取各匹配位置的匹配结果，则应在正则表达式中加入括号

  - ```python
    >>> p = re.compile(r'\W+')
    >>> p2 = re.compile(r'(\W+)')
    >>> p.split('This... is a test.')
    ['This', 'is', 'a', 'test', '']
    >>> p2.split('This... is a test.')
    ['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']
    ```

- `re.split(<正则表达式>, string, maxsplit=0)`

  - 将编译与匹配放在一起执行

### sub()

- `p.sub(replacement, string, count=0)`

  - 找到string中各匹配的位置，使用replacement替换匹配上的字符串，返回替换后的总字符串

  - 匹配时选择满足条件的最长匹配结果，替换的时候也替换的是最长匹配结果

  - ```python
    >>> string = "Cats are smarter than dogs! Dogs are faster than cats!"
    >>> result = re.sub(r'C.*ts', 'Pigs', string)
    >>> print(result)
    Pigs!
    ```

- `re.sub(<正则表达式>, replacement, string, count=0)`

### subn()

- `p.subn(replacement, string, count=0)`

  - `subn()`与`sub()`完成相同的工作，但`subn()`在返回时返回`(替换后结果，替换次数)`这个二元组

  - ```python
    >>> p = re.compile('(blue|white|red)')
    >>> p.subn('colour', 'blue socks and red shoes')
    ('colour socks and colour shoes', 2)
    >>> p.subn('colour', 'no colours at all')
    ('no colours at all', 0)
    ```

  - 对于空匹配`*`，仅当与前一个空匹配不相邻时，才会替换空匹配

  - ```python
    >>> p = re.compile('x*')
    >>> p.sub('-', 'abxd')
    '-a-b--d-'
    ```

    





