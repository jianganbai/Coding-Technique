# python内存机制学习笔记

- 数据类型
  - **可变数据类型**：同地址可修改值，如list, dict, set
  - **不可变数据类型**：必须重开空间，存放修改后的值，如数字、字符串、tuple
- 代码块：函数、条件、循环、模块等，可嵌套
- `id(x)`：查看变量x值的地址

## C语言内存

- 地址由低到高：代码区 => 全局区 => 堆区 => 栈区
  - 代码区：存放代码
  - 全局区：存放全局变量、静态变量等
  - 堆区：用户分配（如malloc），低地址往高地址长
  - 栈区：编译器分配，存放局部变量，高地址往低地址长，先进后出

## 开辟内存

- **变量名指向变量值的指针放在栈区，变量值放在堆区**

### 赋值操作

- **赋值操作：视值的类型决定是否新开空间，然后将引用赋给变量**

  - 若值未被引用，则新开空间，传引用给变量名
  - 若值已被引用（之前已存在内存中）
    - 可变：直接传引用
    - 不可变：新开内存，再传引用（特殊：小整数池、字符串intern、同代码块）

- **浅拷贝**：只存引用

- **深拷贝**：遇到可变则新开内存并存储，遇到不可变则存引用

- 列表

  - ```python
    a = [1, 2, 3, 4]
    b = a[1:]  # 列表的切片运算只传引用
    a[2] = 5  # 只改变a的第2个元素的地址，不改变b的存的地址
    # a: [1, 2, 5, 4]; b: [2, 3, 4]
    ```

### 特殊处理

- **列表存储结构**：每个元素的值单独存，列表对象按顺序存值的地址，变量名再存表头地址

- **小整数池**：[-5, 256]的整数已预先存储在内存中，该区间内整数赋值不新开内存，直接返回
- **字符串intern机制**：若引用的字符串存在，且只含字母数字下划线，则不新开
- 同代码块内，不可变数据被多次引用，则不新开

- **函数调用**：实参赋给形参，是否新开与数据类型有关

## 内存回收

### 引用计数

- 当值被变量的引用次数=0时，回收值所在空间

  - 定期扫描各变量的引用次数

  - 问题：循环引用 => 改进：标记清除

    - ```python
      a, b = [1], [2]
      a.append(b)
      b.append(a)
      del a
      del b  # 值1和2的引用仍为1，无法被删除
      ```

- **del**：删除名与值的关联关系

- **分代回收**：变量获得越久，扫描频率越低

### 标记清除

- 内存空间耗尽，停止程序
- 标记栈区对象能链接到的所有堆区对象
- 删除堆区所有无标记的