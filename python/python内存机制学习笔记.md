# python内存机制学习笔记

- 数据类型
  - **可变数据类型**：同地址可修改值，如list, dict, set
  - **不可变数据类型**：必须重开空间，存放修改后的值，如数字、字符串、tuple
- 代码块：函数、条件、循环、模块等，可嵌套
- `id(x)`：查看变量x值的地址

## C语言内存

- 地址由低到高：代码区 => 全局区 => 堆区 => 栈区
  - 代码区：存放代码
  - 全局区：存放全局变量、静态变量等
  - 堆区：用户分配（如malloc），低地址往高地址长
  - 栈区：编译器分配，存放局部变量，高地址往低地址长，先进后出

## 开辟内存

- **变量名指向变量值的指针放在栈区，变量值放在堆区**

### 赋值操作

- **赋值操作：视值的类型决定是否新开空间，然后将引用赋给变量**

  - 若值未被引用，则新开空间，传引用给变量名
  - 若值已被引用（之前已存在内存中）
    - 可变：直接传引用
    - 不可变：新开内存，再传引用（特殊：小整数池、字符串intern、同代码块）

- **浅拷贝**：只存引用

- **深拷贝**：遇到可变则新开内存并存储，遇到不可变则存引用

- 列表

  - ```python
    a = [1, 2, 3, 4]
    b = a[1:]  # 列表的切片运算只传引用
    a[2] = 5  # 只改变a的第2个元素的地址，不改变b的存的地址
    # a: [1, 2, 5, 4]; b: [2, 3, 4]
    ```

### 特殊处理

- **列表存储结构**：每个元素的值单独存，列表对象按顺序存值的地址，变量名再存表头地址

- **小整数池**：[-5, 256]的整数已预先存储在内存中，该区间内整数赋值不新开内存，直接返回
- **字符串intern机制**：若引用的字符串存在，且只含字母数字下划线，则不新开
- 同代码块内，不可变数据被多次引用，则不新开

- **函数调用**：实参赋给形参，是否新开与数据类型有关

## 内存回收

### 引用计数

- 当值被变量的引用次数=0时，回收值所在空间

  - 定期扫描各变量的引用次数
- `sys.getrefcount(a)`：获取变量a的引用次数
- 减小引用次数的方法
  - **del**：删除名与值的关联关系
  - 同名变量重新赋值
  - 函数调用结束，局部变量销毁

- **分代回收**：3个等级，变量活的越久，扫描频率越低

### 标记清除

- 问题：循环引用 => 改进：**标记清除**

  - ```python
    a, b = [1], [2]
    a.append(b)
    b.append(a)
    del a
    del b  # 值1和2的引用仍为1，无法被删除
    ```

- **循环引用会导致内存泄漏**
  - 内python机制：内存空间耗尽，停止程序
  - 但往往python还没标记清除完，python进程先被系统杀了
- 标记栈区对象能链接到的所有堆区对象
- 删除堆区所有无标记的

### gc库

- gc库：更改垃圾回收的参数
  - `gc.get_count()`：获取执行垃圾回收的计数器
    - 返回3个参数，对应分代回收的3代：自上次回收后，新分配内存次数-释放内存次数
  - `gc.get_threshold()`：获取垃圾回收的频率
  - `gc.set_trheshold(threshold0[, threshold1, threshold2])`：设置垃圾回收的频率
  - `gc.disable()`：关闭gc机制
  - `gc.collect()`：手动执行垃圾回收
- **python无法像c/c++直接回收指定变量**